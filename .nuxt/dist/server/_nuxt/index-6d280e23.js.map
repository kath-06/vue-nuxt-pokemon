{"version":3,"file":"index-6d280e23.js","sources":["../../../../node_modules/nuxt/dist/app/composables/asyncData.js","../../../../node_modules/nuxt/dist/app/composables/ssr.js","../../../../node_modules/nuxt/dist/app/composables/fetch.js","../../../../components/PokemonCard.vue","../../../../components/elements/VnPagination.vue","../../../../pages/pokemons/index.vue"],"sourcesContent":["import { getCurrentInstance, onBeforeMount, onServerPrefetch, onUnmounted, ref, shallowRef, toRef, unref, watch } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { createError } from \"./error.js\";\nimport { onNuxtReady } from \"./ready.js\";\nimport { asyncDataDefaults } from \"#build/nuxt.config.mjs\";\nexport function useAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (typeof args[0] !== \"string\") {\n    args.unshift(autoKey);\n  }\n  let [key, handler, options = {}] = args;\n  if (typeof key !== \"string\") {\n    throw new TypeError(\"[nuxt] [asyncData] key must be a string.\");\n  }\n  if (typeof handler !== \"function\") {\n    throw new TypeError(\"[nuxt] [asyncData] handler must be a function.\");\n  }\n  const nuxt = useNuxtApp();\n  const getDefault = () => null;\n  const getDefaultCachedData = () => nuxt.isHydrating ? nuxt.payload.data[key] : nuxt.static.data[key];\n  options.server = options.server ?? true;\n  options.default = options.default ?? getDefault;\n  options.getCachedData = options.getCachedData ?? getDefaultCachedData;\n  options.lazy = options.lazy ?? false;\n  options.immediate = options.immediate ?? true;\n  options.deep = options.deep ?? asyncDataDefaults.deep;\n  const hasCachedData = () => ![null, void 0].includes(options.getCachedData(key));\n  if (!nuxt._asyncData[key] || !options.immediate) {\n    nuxt.payload._errors[key] ??= null;\n    const _ref = options.deep ? ref : shallowRef;\n    nuxt._asyncData[key] = {\n      data: _ref(options.getCachedData(key) ?? options.default()),\n      pending: ref(!hasCachedData()),\n      error: toRef(nuxt.payload._errors, key),\n      status: ref(\"idle\")\n    };\n  }\n  const asyncData = { ...nuxt._asyncData[key] };\n  asyncData.refresh = asyncData.execute = (opts = {}) => {\n    if (nuxt._asyncDataPromises[key]) {\n      if (opts.dedupe === false) {\n        return nuxt._asyncDataPromises[key];\n      }\n      nuxt._asyncDataPromises[key].cancelled = true;\n    }\n    if ((opts._initial || nuxt.isHydrating && opts._initial !== false) && hasCachedData()) {\n      return Promise.resolve(options.getCachedData(key));\n    }\n    asyncData.pending.value = true;\n    asyncData.status.value = \"pending\";\n    const promise = new Promise(\n      (resolve, reject) => {\n        try {\n          resolve(handler(nuxt));\n        } catch (err) {\n          reject(err);\n        }\n      }\n    ).then((_result) => {\n      if (promise.cancelled) {\n        return nuxt._asyncDataPromises[key];\n      }\n      let result = _result;\n      if (options.transform) {\n        result = options.transform(_result);\n      }\n      if (options.pick) {\n        result = pick(result, options.pick);\n      }\n      asyncData.data.value = result;\n      asyncData.error.value = null;\n      asyncData.status.value = \"success\";\n    }).catch((error) => {\n      if (promise.cancelled) {\n        return nuxt._asyncDataPromises[key];\n      }\n      asyncData.error.value = error;\n      asyncData.data.value = unref(options.default());\n      asyncData.status.value = \"error\";\n    }).finally(() => {\n      if (promise.cancelled) {\n        return;\n      }\n      asyncData.pending.value = false;\n      nuxt.payload.data[key] = asyncData.data.value;\n      if (asyncData.error.value) {\n        nuxt.payload._errors[key] = createError(asyncData.error.value);\n      }\n      delete nuxt._asyncDataPromises[key];\n    });\n    nuxt._asyncDataPromises[key] = promise;\n    return nuxt._asyncDataPromises[key];\n  };\n  const initialFetch = () => asyncData.refresh({ _initial: true });\n  const fetchOnServer = options.server !== false && nuxt.payload.serverRendered;\n  if (import.meta.server && fetchOnServer && options.immediate) {\n    const promise = initialFetch();\n    if (getCurrentInstance()) {\n      onServerPrefetch(() => promise);\n    } else {\n      nuxt.hook(\"app:created\", async () => {\n        await promise;\n      });\n    }\n  }\n  if (import.meta.client) {\n    const instance = getCurrentInstance();\n    if (instance && !instance._nuxtOnBeforeMountCbs) {\n      instance._nuxtOnBeforeMountCbs = [];\n      const cbs = instance._nuxtOnBeforeMountCbs;\n      if (instance) {\n        onBeforeMount(() => {\n          cbs.forEach((cb) => {\n            cb();\n          });\n          cbs.splice(0, cbs.length);\n        });\n        onUnmounted(() => cbs.splice(0, cbs.length));\n      }\n    }\n    if (asyncData.error.value || fetchOnServer && nuxt.isHydrating && hasCachedData()) {\n      asyncData.pending.value = false;\n      asyncData.status.value = asyncData.error.value ? \"error\" : \"success\";\n    } else if (instance && (nuxt.payload.serverRendered && nuxt.isHydrating || options.lazy) && options.immediate) {\n      instance._nuxtOnBeforeMountCbs.push(initialFetch);\n    } else if (options.immediate) {\n      initialFetch();\n    }\n    if (options.watch) {\n      watch(options.watch, () => asyncData.refresh());\n    }\n    const off = nuxt.hook(\"app:data:refresh\", async (keys) => {\n      if (!keys || keys.includes(key)) {\n        await asyncData.refresh();\n      }\n    });\n    if (instance) {\n      onUnmounted(off);\n    }\n  }\n  const asyncDataPromise = Promise.resolve(nuxt._asyncDataPromises[key]).then(() => asyncData);\n  Object.assign(asyncDataPromise, asyncData);\n  return asyncDataPromise;\n}\nexport function useLazyAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (typeof args[0] !== \"string\") {\n    args.unshift(autoKey);\n  }\n  const [key, handler, options] = args;\n  return useAsyncData(key, handler, { ...options, lazy: true }, null);\n}\nexport function useNuxtData(key) {\n  const nuxt = useNuxtApp();\n  if (!(key in nuxt.payload.data)) {\n    nuxt.payload.data[key] = null;\n  }\n  return {\n    data: toRef(nuxt.payload.data, key)\n  };\n}\nexport async function refreshNuxtData(keys) {\n  if (import.meta.server) {\n    return Promise.resolve();\n  }\n  await new Promise((resolve) => onNuxtReady(resolve));\n  const _keys = keys ? Array.isArray(keys) ? keys : [keys] : void 0;\n  await useNuxtApp().hooks.callHookParallel(\"app:data:refresh\", _keys);\n}\nexport function clearNuxtData(keys) {\n  const nuxtApp = useNuxtApp();\n  const _allKeys = Object.keys(nuxtApp.payload.data);\n  const _keys = !keys ? _allKeys : typeof keys === \"function\" ? _allKeys.filter(keys) : Array.isArray(keys) ? keys : [keys];\n  for (const key of _keys) {\n    if (key in nuxtApp.payload.data) {\n      nuxtApp.payload.data[key] = void 0;\n    }\n    if (key in nuxtApp.payload._errors) {\n      nuxtApp.payload._errors[key] = null;\n    }\n    if (nuxtApp._asyncData[key]) {\n      nuxtApp._asyncData[key].data.value = void 0;\n      nuxtApp._asyncData[key].error.value = null;\n      nuxtApp._asyncData[key].pending.value = false;\n      nuxtApp._asyncData[key].status.value = \"idle\";\n    }\n    if (key in nuxtApp._asyncDataPromises) {\n      nuxtApp._asyncDataPromises[key] = void 0;\n    }\n  }\n}\nfunction pick(obj, keys) {\n  const newObj = {};\n  for (const key of keys) {\n    newObj[key] = obj[key];\n  }\n  return newObj;\n}\n","import { setResponseStatus as _setResponseStatus, appendHeader, getRequestHeaders } from \"h3\";\nimport { useNuxtApp } from \"../nuxt.js\";\nexport function useRequestHeaders(include) {\n  if (import.meta.client) {\n    return {};\n  }\n  const event = useNuxtApp().ssrContext?.event;\n  const headers = event ? getRequestHeaders(event) : {};\n  if (!include) {\n    return headers;\n  }\n  return Object.fromEntries(include.map((key) => key.toLowerCase()).filter((key) => headers[key]).map((key) => [key, headers[key]]));\n}\nexport function useRequestEvent(nuxtApp = useNuxtApp()) {\n  return nuxtApp.ssrContext?.event;\n}\nexport function useRequestFetch() {\n  if (import.meta.client) {\n    return globalThis.$fetch;\n  }\n  const event = useNuxtApp().ssrContext?.event;\n  return event?.$fetch || globalThis.$fetch;\n}\nexport function setResponseStatus(arg1, arg2, arg3) {\n  if (import.meta.client) {\n    return;\n  }\n  if (arg1 && typeof arg1 !== \"number\") {\n    return _setResponseStatus(arg1, arg2, arg3);\n  }\n  return _setResponseStatus(useRequestEvent(), arg1, arg2);\n}\nexport function prerenderRoutes(path) {\n  if (!process.server || !process.env.prerender) {\n    return;\n  }\n  const paths = Array.isArray(path) ? path : [path];\n  appendHeader(useRequestEvent(), \"x-nitro-prerender\", paths.map((p) => encodeURIComponent(p)).join(\", \"));\n}\n","import { computed, reactive, unref } from \"vue\";\nimport { hash } from \"ohash\";\nimport { useRequestFetch } from \"./ssr.js\";\nimport { useAsyncData } from \"./asyncData.js\";\nimport { fetchDefaults } from \"#build/nuxt.config.mjs\";\nexport function useFetch(request, arg1, arg2) {\n  const [opts = {}, autoKey] = typeof arg1 === \"string\" ? [{}, arg1] : [arg1, arg2];\n  const _request = computed(() => {\n    let r = request;\n    if (typeof r === \"function\") {\n      r = r();\n    }\n    return unref(r);\n  });\n  const _key = opts.key || hash([autoKey, unref(opts.method)?.toUpperCase() || \"GET\", unref(opts.baseURL), typeof _request.value === \"string\" ? _request.value : \"\", unref(opts.params || opts.query), unref(opts.headers)]);\n  if (!_key || typeof _key !== \"string\") {\n    throw new TypeError(\"[nuxt] [useFetch] key must be a string: \" + _key);\n  }\n  if (!request) {\n    throw new Error(\"[nuxt] [useFetch] request is missing.\");\n  }\n  const key = _key === autoKey ? \"$f\" + _key : _key;\n  if (!opts.baseURL && typeof _request.value === \"string\" && _request.value.startsWith(\"//\")) {\n    throw new Error('[nuxt] [useFetch] the request URL must not start with \"//\".');\n  }\n  const {\n    server,\n    lazy,\n    default: defaultFn,\n    transform,\n    pick,\n    watch,\n    immediate,\n    getCachedData,\n    deep,\n    ...fetchOptions\n  } = opts;\n  const _fetchOptions = reactive({\n    ...fetchDefaults,\n    ...fetchOptions,\n    cache: typeof opts.cache === \"boolean\" ? void 0 : opts.cache\n  });\n  const _asyncDataOptions = {\n    server,\n    lazy,\n    default: defaultFn,\n    transform,\n    pick,\n    immediate,\n    getCachedData,\n    deep,\n    watch: watch === false ? [] : [_fetchOptions, _request, ...watch || []]\n  };\n  let controller;\n  const asyncData = useAsyncData(key, () => {\n    controller?.abort?.();\n    controller = typeof AbortController !== \"undefined\" ? new AbortController() : {};\n    const isLocalFetch = typeof _request.value === \"string\" && _request.value.startsWith(\"/\");\n    let _$fetch = opts.$fetch || globalThis.$fetch;\n    if (import.meta.server && !opts.$fetch && isLocalFetch) {\n      _$fetch = useRequestFetch();\n    }\n    return _$fetch(_request.value, { signal: controller.signal, ..._fetchOptions });\n  }, _asyncDataOptions);\n  return asyncData;\n}\nexport function useLazyFetch(request, arg1, arg2) {\n  const [opts, autoKey] = typeof arg1 === \"string\" ? [{}, arg1] : [arg1, arg2];\n  return useFetch(\n    request,\n    {\n      ...opts,\n      lazy: true\n    },\n    // @ts-expect-error we pass an extra argument with the resolved auto-key to prevent another from being injected\n    autoKey\n  );\n}\n","<template>\r\n  <div class=\"flip-card card-primary\">\r\n    <div class=\"flip-card-inner preserve-3d\">\r\n      <div class=\"flip-card-front\">\r\n        <img\r\n          class=\"w-3/4 h-1/2\"\r\n          v-show=\"pokemon.id !== '1013'\"\r\n          :src=\"`${imgUrl}${pokemon.id}.png`\"\r\n        />\r\n        <p class=\"text-title-default\">\r\n          {{ pokemon.name }}\r\n        </p>\r\n      </div>\r\n      <div class=\"flip-card-back\">\r\n        <div class=\"text-title-primary\">\r\n          {{ pokemon.name }}\r\n        </div>\r\n        <div class=\"p-2\">\r\n          <img\r\n            v-if=\"parseInt(pokemon.id) < 650\"\r\n            :src=\"`${gifUrl}${pokemon.id}.gif`\"\r\n          />\r\n          <img\r\n            v-else\r\n            :src=\"`${backImgUrl}${pokemon.id}.png`\"\r\n          />\r\n        </div>\r\n        <NuxtLink :to=\"`/pokemons/${pokemon.id}`\" >\r\n          <VnButton>View</VnButton>\r\n        </NuxtLink>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport VnButton from './elements/VnButton.vue';\r\n\r\nconst props = defineProps({\r\n  pokemonData: {\r\n    type: Object,\r\n    default: () => {}\r\n  }\r\n})\r\n\r\nlet pokemon = reactive<any>({})\r\nlet imgUrl = 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/'\r\nlet backImgUrl = 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/'\r\nlet gifUrl = 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/'\r\n\r\nonBeforeMount(() => {\r\n  Object.assign(pokemon, {})\r\n  Object.assign(pokemon, props.pokemonData)\r\n})\r\n\r\nwatch(() => toRefs(props.pokemonData), () => {\r\n  Object.assign(pokemon, {})\r\n  Object.assign(pokemon, props.pokemonData)\r\n})\r\n\r\n</script>\r\n\r\n<style lang=\"scss\">\r\n  .preserve-3d {\r\n    transform-style: preserve-3d;\r\n  }\r\n\r\n  .flip-card:hover {\r\n    .flip-card-inner {\r\n      transform: rotateY(180deg);\r\n    }\r\n  }\r\n\r\n  .flip-card-front, .flip-card-back {\r\n    -webkit-backface-visibility: hidden; /* Safari */\r\n    backface-visibility: hidden;\r\n  }\r\n\r\n   /* Style the back side */\r\n   .flip-card-back {\r\n    transform: rotateY(180deg);\r\n  }\r\n\r\n</style>","<template>\r\n  <div class=\"flex justify-end\">\r\n    <button\r\n      v-show=\"showPrev\"\r\n      class=\"pagination-prv-btn\"\r\n      @click=\"handlePrev\"\r\n    >\r\n      Prev\r\n    </button>\r\n    <button\r\n      :disabled=\"activePage === index ? true : false\"\r\n      :class=\"activePage === index ? 'disable-pagination-btn' : 'pagination-btn'\"\r\n      v-for=\"(page, index) in pagesCount\"\r\n      :key=\"index\"\r\n      @click=\"handlePage(index)\"\r\n    >\r\n      {{index + 1}}\r\n    </button>\r\n    <button\r\n      v-show=\"showNext\"\r\n      class=\"pagination-nxt-btn\"\r\n      @click=\"handleNext\"\r\n    >\r\n      Next\r\n    </button>\r\n  </div>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nconst props = defineProps({\r\n  count: {\r\n    type: Number,\r\n    default: 0\r\n  },\r\n  itemPerPage: {\r\n    type: Number,\r\n    default: 120\r\n  },\r\n  showPrev: {\r\n    type: Boolean,\r\n    default: false\r\n  },\r\n  showNext: {\r\n    type: Boolean,\r\n    default: false\r\n  },\r\n  activePage: {\r\n    type: Number,\r\n    default: 0\r\n  }\r\n})\r\nconst emits = defineEmits(['prev', 'next', 'page'])\r\n\r\nlet pagesCount = ref<number>(0)\r\n\r\nconst handlePrev = () => {\r\n  emits('prev', props.activePage - 1)\r\n}\r\nconst handleNext = () => {\r\n  emits('next', props.activePage + 1)\r\n}\r\nconst handlePage = (pageNum: number) => {\r\n  emits('page', (pageNum * props.itemPerPage), pageNum)\r\n}\r\n\r\nwatch(() => props.count, () => {\r\n  pagesCount.value = Math.ceil(props.count / props.itemPerPage)\r\n})\r\n</script>","<template>\r\n  <div class=\"p-4\">\r\n    <VnPageHeader text=\"Pokemon List\" />\r\n    <VnLoading :loading=\"loading\" />\r\n    <div v-show=\"!loading\">\r\n      <div class=\"grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-5\">\r\n        <div\r\n          v-for=\"(item, index) in pokemons\"\r\n          :key=\"index\">\r\n          <PokemonCard :pokemon-data=\"item\" />\r\n        </div>\r\n      </div>\r\n      <VnPagination\r\n        :count=\"count\"\r\n        :show-prev=\"showPrev\"\r\n        :show-next=\"showNext\"\r\n        :active-page=\"activePage\"\r\n        :itemPerPage=\"itemPerPage\"\r\n        @prev=\"handlePrev\"\r\n        @next=\"handleNext\"\r\n        @page=\"handlePage\"\r\n      />\r\n    </div>\r\n  </div>\r\n</template>\r\n<script setup lang=\"ts\">\r\nimport VnPagination from '~/components/elements/VnPagination.vue'\r\nimport VnLoading from '~/components/elements/VnLoading.vue'\r\nimport VnPageHeader from '~/components/elements/VnPageHeader.vue'\r\n\r\nuseHead({\r\n  title: 'Vue-Nuxt | Pokemon List'\r\n})\r\n\r\nlet pokemons = reactive<any>([])\r\nlet limit = ref<number>(120)\r\nlet offset = ref<number>(0)\r\nlet count = ref<number>(0)\r\nlet nextOffset = ref<any>(0)\r\nlet prevOffset = ref<any>(0)\r\nlet loading = ref<boolean>(true)\r\nlet showPrev = ref<boolean>(true)\r\nlet showNext = ref<boolean>(true)\r\nlet activePage = ref<number>(0)\r\nlet itemPerPage = ref<number>(120)\r\n\r\nconst getPokemon = async (offsetData: any) => {\r\n  let dataResults = []\r\n  const { data, refresh } : any = await useFetch(`/api/pokemon?offset=${offsetData}&limit=${limit.value}`, { query: { type: 'getList' } })\r\n  if (data.value === null) {\r\n    await refresh()\r\n  }\r\n  const nextUrl = data.value.next;\r\n  const prevUrl = data.value.previous;\r\n\r\n  if (nextUrl) {\r\n    const nextUrlParams = new URL(nextUrl)\r\n    nextOffset.value = nextUrlParams.searchParams.get(\"offset\") || 0\r\n  }\r\n  if (prevUrl) {\r\n    const prevUrlParams = new URL(prevUrl)\r\n    prevOffset.value = prevUrlParams.searchParams.get(\"offset\") || 0\r\n  }\r\n  dataResults = data.value.results\r\n  dataResults.map((item: any) => {\r\n    const dataId = getId(item.url)\r\n    Object.assign(item, { ...item, id: dataId})\r\n  })\r\n  \r\n  count.value = 1017\r\n  showNext.value = nextOffset.value > count.value ? false : true\r\n  showPrev.value = prevUrl === null ? false : true\r\n  Object.assign(pokemons, dataResults)\r\n  loading.value = false\r\n}\r\n\r\nconst getId = (url: string) => {\r\n  const lastSlashindex = url.lastIndexOf('/')\r\n  const secondLastSlashIndex = url.lastIndexOf('/', lastSlashindex - 1)\r\n  const urlId = url.slice(secondLastSlashIndex + 1, lastSlashindex)\r\n\r\n  return urlId\r\n}\r\n\r\nconst loadPage = (offset: any) => {\r\n  const localActivePage = localStorage.getItem('activePage')\r\n  let offsetValue = offset\r\n\r\n  loading.value = true\r\n  if (activePage.value === 0 && localActivePage) {\r\n    setActivePage(parseInt(localActivePage))\r\n    offsetValue = parseInt(localActivePage) * itemPerPage.value\r\n  }\r\n  setTimeout(() => {\r\n    getPokemon(offsetValue)\r\n  }, 2000)\r\n}\r\n\r\nconst handlePrev = (pageNum: number) => {\r\n  setActivePage(pageNum)\r\n  loadPage(prevOffset.value)\r\n}\r\n\r\nconst handleNext = (pageNum: number) => {\r\n  setActivePage(pageNum)\r\n  loadPage(nextOffset.value)\r\n}\r\n\r\nconst handlePage = (pageOffset: number, pageNum: number) => {\r\n  setActivePage(pageNum)\r\n  loadPage(pageOffset)\r\n}\r\n\r\nconst setActivePage = (pageNum: number) => {\r\n  localStorage.setItem('activePage', pageNum.toString())\r\n  activePage.value = pageNum\r\n}\r\n\r\nonMounted(() => {\r\n  loadPage(offset.value)\r\n})\r\n</script>"],"names":["pick","watch","_a","offset"],"mappings":"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","x_google_ignoreList":[0,1,2]}